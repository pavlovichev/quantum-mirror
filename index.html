<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Œî-–ö–≤–∞–Ω—Ç–æ–≤–æ–µ –ó–µ—Ä–∫–∞–ª–æ (–†–∞–±–æ—á–∞—è –≤–µ—Ä—Å–∏—è)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
  <style>
    :root {
      --quantum-blue: #0b3d91;
      --pulse-orange: #ff6d00;
      --signal-purple: #9c27b0;
      --entropy-green: #00c853;
    }
    body {
      font-family: 'Segoe UI', sans-serif;
      margin: 0;
      padding: 0;
      background: #f0f2f5;
      color: #333;
      line-height: 1.6;
    }
    .container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
    }
    .panel {
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.08);
      padding: 25px;
      margin-bottom: 30px;
      border-left: 5px solid var(--quantum-blue);
    }
    h1, h2 {
      color: var(--quantum-blue);
      margin-top: 0;
    }
    canvas {
      width: 100% !important;
      height: 300px !important;
      margin: 15px 0;
      border: 1px solid #eee;
      border-radius: 8px;
    }
    button, select {
      background: var(--quantum-blue);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 8px;
      cursor: pointer;
      margin: 5px;
      font-size: 14px;
      transition: all 0.3s;
    }
    button:hover {
      background: var(--pulse-orange);
      transform: translateY(-2px);
    }
    .slider-container {
      margin: 15px 0;
    }
    .metric {
      display: inline-block;
      margin: 8px;
      padding: 8px 12px;
      background: #e0e0e0;
      border-radius: 8px;
      font-size: 14px;
    }
    .active {
      background: var(--signal-purple) !important;
    }
    #audioVisualizer {
      width: 100%;
      height: 150px;
      background: #000;
      border-radius: 8px;
      margin: 10px 0;
    }
    #imageOutput {
      max-width: 100%;
      border: 1px solid #ddd;
      border-radius: 8px;
      margin-top: 15px;
    }
    .tab-container {
      display: flex;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    .tab {
      padding: 8px 15px;
      background: #ddd;
      cursor: pointer;
      border-radius: 8px 8px 0 0;
      margin-right: 5px;
      font-size: 14px;
    }
    .tab.active {
      background: var(--quantum-blue);
      color: white;
    }
    textarea, input[type="text"] {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 8px;
      margin: 5px 0;
    }
    pre {
      background: #f5f5f5;
      padding: 10px;
      border-radius: 8px;
      overflow-x: auto;
    }
    #qSphere {
      width: 200px;
      height: 200px;
      margin: 0 auto;
      display: block;
    }
    .status {
      padding: 8px;
      border-radius: 4px;
      margin: 5px 0;
      font-size: 13px;
    }
    .success {
      background: #e8f5e9;
      color: #00c853;
    }
    .error {
      background: #ffebee;
      color: #f44336;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Œî-–ö–≤–∞–Ω—Ç–æ–≤–æ–µ –ó–µ—Ä–∫–∞–ª–æ (–†–∞–±–æ—á–∞—è –≤–µ—Ä—Å–∏—è)</h1>
    
    <!-- 1. –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å–∏–≥–Ω–∞–ª–æ–≤ -->
    <div class="panel">
      <h2>1. –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∫–≤–∞–Ω—Ç–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤</h2>
      
      <div class="tab-container">
        <div class="tab active" onclick="switchTab('analog')">–ê–Ω–∞–ª–æ–≥–æ–≤—ã–π</div>
        <div class="tab" onclick="switchTab('digital')">–¶–∏—Ñ—Ä–æ–≤–æ–π</div>
        <div class="tab" onclick="switchTab('quantum')">Q-—Å—Ñ–µ—Ä–∞</div>
      </div>
      
      <div id="analog-tab">
        <div class="slider-container">
          <label>–ß–∞—Å—Ç–æ—Ç–∞: <span id="freqValue">440</span> –ì—Ü</label>
          <input type="range" id="freqSlider" min="20" max="2000" value="440" oninput="updateSignal()">
        </div>
        
        <div class="slider-container">
          <label>–®—É–º: <span id="noiseValue">30</span>%</label>
          <input type="range" id="noiseSlider" min="0" max="100" value="30" oninput="updateSignal()">
        </div>
        
        <canvas id="signalChart"></canvas>
        
        <button onclick="startAudio()">‚ñ∂ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å</button>
        <button onclick="stopAudio()">‚ñ† –°—Ç–æ–ø</button>
        <button onclick="exportToCSV()">üìä CSV</button>
        <button onclick="applyQuantumGate('H')">‚ö° –í–µ–Ω—Ç–∏–ª—å –ê–¥–∞–º–∞—Ä–∞</button>
      </div>
      
      <div id="digital-tab" style="display:none;">
        <textarea id="digitalInput" rows="3" placeholder="–í–≤–µ–¥–∏—Ç–µ –±–∏—Ç—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä: 01001101)">01001101</textarea>
        <button onclick="processDigital()">–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å</button>
        <button onclick="generateRandomBits()">üé≤ –°–ª—É—á–∞–π–Ω—ã–µ –±–∏—Ç—ã</button>
        <canvas id="digitalChart"></canvas>
        <img id="imageOutput" src="" alt="–¶–∏—Ñ—Ä–æ–≤–æ–π –æ–±—Ä–∞–∑">
      </div>
      
      <div id="quantum-tab" style="display:none; text-align:center;">
        <canvas id="qSphere" width="200" height="200"></canvas>
        <div>
          <span class="metric">|0‚ü©: <span id="state0">0.71</span></span>
          <span class="metric">|1‚ü©: <span id="state1">0.71</span></span>
          <span class="metric">Œ∏: <span id="theta">45</span>¬∞</span>
        </div>
        <button onclick="updateQSphere()">–û–±–Ω–æ–≤–∏—Ç—å</button>
      </div>
    </div>
    
    <!-- 2. –ê–Ω–∞–ª–∏–∑ -->
    <div class="panel">
      <h2>2. –ù–µ–π—Ä–æ—Å–µ—Ç–µ–≤–æ–π –∞–Ω–∞–ª–∏–∑</h2>
      <select id="aiModel">
        <option value="noise">–ê–Ω–∞–ª–∏–∑ —à—É–º–∞</option>
        <option value="pattern">–ü–∞—Ç—Ç–µ—Ä–Ω—ã</option>
      </select>
      <button onclick="runAnalysis()">üîç –ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å</button>
      <div id="aiResults" style="margin-top:15px;">
        <pre id="aiOutput">–ù–∞–∂–º–∏—Ç–µ "–ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å"</pre>
      </div>
    </div>
    
    <!-- 3. –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ -->
    <div class="panel">
      <h2>3. –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏</h2>
      <button onclick="connectTelegram()">ü§ñ Telegram-–±–æ—Ç</button>
      <button onclick="generateColabCode()">üñ•Ô∏è –ö–æ–¥ –¥–ª—è Colab</button>
      <div id="integrationStatus" class="status">–°—Ç–∞—Ç—É—Å: –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–æ</div>
      <pre id="colabCode" style="display:none; margin-top:10px;"></pre>
    </div>
    
    <!-- 4. –õ–æ–≥–∏ -->
    <div class="panel">
      <h2>4. –°–∏—Å—Ç–µ–º–Ω—ã–µ –ª–æ–≥–∏</h2>
      <pre id="systemLogs" style="height:150px; overflow-y:scroll;">
[–°–∏—Å—Ç–µ–º–∞] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞
[–ê—É–¥–∏–æ] –ì–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ
[TF.js] –ú–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞
      </pre>
      <button onclick="clearLogs()">üßπ –û—á–∏—Å—Ç–∏—Ç—å</button>
      <button onclick="exportLogs()">üì§ –≠–∫—Å–ø–æ—Ä—Ç</button>
    </div>
  </div>

  <script>
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    let audioContext, oscillator, analyser, isPlaying = false;
    let charts = {};
    let tfModel = null;
    let qState = { alpha: 0.7071, beta: 0.7071, theta: Math.PI/4 };

    // –ó–∞–ø—É—Å–∫ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
    document.addEventListener('DOMContentLoaded', function() {
      initCharts();
      updateSignal();
      initTFJS();
      updateQSphere();
      logEvent("–°–∏—Å—Ç–µ–º–∞ –≥–æ—Ç–æ–≤–∞");
    });

    // 1. –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å–∏–≥–Ω–∞–ª–æ–≤
    function switchTab(tabName) {
      document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
      document.querySelector(`.tab[onclick*="${tabName}"]`).classList.add('active');
      document.getElementById('analog-tab').style.display = tabName === 'analog' ? 'block' : 'none';
      document.getElementById('digital-tab').style.display = tabName === 'digital' ? 'block' : 'none';
      document.getElementById('quantum-tab').style.display = tabName === 'quantum' ? 'block' : 'none';
    }

    function updateSignal() {
      const freq = parseInt(document.getElementById('freqSlider').value);
      const noise = parseInt(document.getElementById('noiseSlider').value);
      document.getElementById('freqValue').textContent = freq;
      document.getElementById('noiseValue').textContent = noise;

      // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–∏–≥–Ω–∞–ª–∞ —Å —à—É–º–æ–º
      const signal = [];
      for (let i = 0; i < 200; i++) {
        signal.push(Math.sin(i * freq * 0.02) + (Math.random() * 2 - 1) * noise * 0.01);
      }
      updateChart('signalChart', signal, '–°–∏–≥–Ω–∞–ª', '#ff6d00');
    }

    function startAudio() {
      if (isPlaying) return;
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        oscillator = audioContext.createOscillator();
        analyser = audioContext.createAnalyser();
        oscillator.type = 'sine';
        oscillator.frequency.value = document.getElementById('freqSlider').value;
        oscillator.connect(analyser);
        analyser.connect(audioContext.destination);
        oscillator.start();
        isPlaying = true;
        visualizeAudio();
        logEvent("–ê—É–¥–∏–æ –∑–∞–ø—É—â–µ–Ω–æ");
      } catch (e) {
        logEvent(`–û—à–∏–±–∫–∞ –∞—É–¥–∏–æ: ${e.message}`, true);
      }
    }

    function stopAudio() {
      if (!isPlaying) return;
      oscillator.stop();
      isPlaying = false;
      logEvent("–ê—É–¥–∏–æ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ");
    }

    function visualizeAudio() {
      if (!isPlaying) return;
      const canvas = document.getElementById('audioVisualizer');
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      analyser.fftSize = 256;
      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);

      function draw() {
        requestAnimationFrame(draw);
        analyser.getByteFrequencyData(dataArray);
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.fillRect(0, 0, width, height);
        const barWidth = (width / bufferLength) * 2.5;
        let x = 0;
        for (let i = 0; i < bufferLength; i++) {
          const barHeight = dataArray[i] / 2;
          ctx.fillStyle = `rgb(100, ${Math.floor(barHeight + 100)}, 50)`;
          ctx.fillRect(x, height - barHeight, barWidth, barHeight);
          x += barWidth + 1;
        }
      }
      draw();
    }

    // 2. –¶–∏—Ñ—Ä–æ–≤–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞
    function processDigital() {
      const input = document.getElementById('digitalInput').value;
      const binaryData = input.split('').filter(c => c === '0' || c === '1').map(bit => parseInt(bit));
      if (binaryData.length === 0) {
        logEvent("–û—à–∏–±–∫–∞: –≤–≤–µ–¥–∏—Ç–µ –±–∏—Ç—ã 0 –∏ 1", true);
        return;
      }
      updateChart('digitalChart', binaryData, '–¶–∏—Ñ—Ä–æ–≤–æ–π —Å–∏–≥–Ω–∞–ª', '#0b3d91');
      generateImage(binaryData);
      logEvent(`–û–±—Ä–∞–±–æ—Ç–∞–Ω–æ ${binaryData.length} –±–∏—Ç`);
    }

    function generateImage(bits) {
      const canvas = document.createElement('canvas');
      const size = 32;
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      let index = 0;
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const bit = bits[index % bits.length];
          ctx.fillStyle = bit ? '#ff6d00' : '#0b3d91';
          ctx.fillRect(x, y, 1, 1);
          index++;
        }
      }
      document.getElementById('imageOutput').src = canvas.toDataURL();
    }

    function generateRandomBits() {
      const bits = Array.from({length: 16}, () => Math.round(Math.random()));
      document.getElementById('digitalInput').value = bits.join('');
      processDigital();
    }

    // 3. Q-—Å—Ñ–µ—Ä–∞
    function updateQSphere() {
      const canvas = document.getElementById('qSphere');
      const ctx = canvas.getContext('2d');
      const radius = canvas.width / 2 - 10;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // –°—Ñ–µ—Ä–∞
      ctx.beginPath();
      ctx.arc(canvas.width/2, canvas.height/2, radius, 0, 2 * Math.PI);
      ctx.strokeStyle = '#0b3d91';
      ctx.stroke();
      
      // –ö—É–±–∏—Ç
      const x = canvas.width/2 + radius * Math.sin(qState.theta);
      const y = canvas.height/2 - radius * Math.cos(qState.theta);
      ctx.beginPath();
      ctx.arc(x, y, 8, 0, 2 * Math.PI);
      ctx.fillStyle = '#ff6d00';
      ctx.fill();
      
      document.getElementById('state0').textContent = qState.alpha.toFixed(2);
      document.getElementById('state1').textContent = qState.beta.toFixed(2);
      document.getElementById('theta').textContent = Math.round(qState.theta * 180 / Math.PI);
    }

    function applyQuantumGate(gate) {
      if (gate === 'H') {
        // –í–µ–Ω—Ç–∏–ª—å –ê–¥–∞–º–∞—Ä–∞
        const newAlpha = (qState.alpha + qState.beta) / Math.sqrt(2);
        const newBeta = (qState.alpha - qState.beta) / Math.sqrt(2);
        qState.alpha = newAlpha;
        qState.beta = newBeta;
        qState.theta = Math.acos(newAlpha) * 2;
      }
      updateQSphere();
      logEvent(`–ü—Ä–∏–º–µ–Ω—ë–Ω –∫–≤–∞–Ω—Ç–æ–≤—ã–π –≤–µ–Ω—Ç–∏–ª—å ${gate}`);
    }

    // 4. TensorFlow.js
    async function initTFJS() {
      try {
        await tf.ready();
        // –ü—Ä–æ—Å—Ç–∞—è –º–æ–¥–µ–ª—å –¥–ª—è –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏
        tfModel = tf.sequential();
        tfModel.add(tf.layers.dense({ units: 8, activation: 'relu', inputShape: [10] }));
        tfModel.add(tf.layers.dense({ units: 2, activation: 'softmax' }));
        tfModel.compile({ optimizer: 'adam', loss: 'categoricalCrossentropy' });
        
        // –ò–º–∏—Ç–∞—Ü–∏—è –æ–±—É—á–µ–Ω–∏—è
        const xs = tf.tensor2d([...Array(10)].map(() => [...Array(10)].map(Math.random)));
        const ys = tf.tensor2d([...Array(10)].map(() => [Math.random(), Math.random()]));
        await tfModel.fit(xs, ys, { epochs: 1 });
        
        logEvent("TF.js –º–æ–¥–µ–ª—å –≥–æ—Ç–æ–≤–∞");
      } catch (e) {
        logEvent(`–û—à–∏–±–∫–∞ TF.js: ${e.message}`, true);
      }
    }

    async function runAnalysis() {
      if (!tfModel) {
        logEvent("–ú–æ–¥–µ–ª—å –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞", true);
        return;
      }
      const modelType = document.getElementById('aiModel').value;
      const input = tf.tensor2d([[...Array(10)].map(Math.random)]);
      const prediction = await tfModel.predict(input).data();
      
      let result;
      if (modelType === 'noise') {
        result = `–£—Ä–æ–≤–µ–Ω—å —à—É–º–∞: ${(prediction[0] * 100).toFixed(1)}%\n–ö–æ–≥–µ—Ä–µ–Ω—Ç–Ω–æ—Å—Ç—å: ${(prediction[1] * 100).toFixed(1)}%`;
      } else {
        result = `–ü–∞—Ç—Ç–µ—Ä–Ω |0‚ü©: ${(prediction[0] * 100).toFixed(1)}%\n–ü–∞—Ç—Ç–µ—Ä–Ω |1‚ü©: ${(prediction[1] * 100).toFixed(1)}%`;
      }
      document.getElementById('aiOutput').textContent = result;
      logEvent(`–ê–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à–µ–Ω (${modelType})`);
    }

    // 5. –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏
    function connectTelegram() {
      localStorage.setItem('telegramBotConnected', 'true');
      document.getElementById('integrationStatus').className = "status success";
      document.getElementById('integrationStatus').textContent = "Telegram: –ø–æ–¥–∫–ª—é—á–µ–Ω (—ç–º—É–ª—è—Ü–∏—è)";
      logEvent("Telegram-–±–æ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω (–¥–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ localStorage)");
    }

    function generateColabCode() {
      const code = `# –ö–æ–¥ –¥–ª—è Google Colab
import numpy as np
from qiskit import QuantumCircuit, execute, Aer

# –°–æ–∑–¥–∞–µ–º –∫–≤–∞–Ω—Ç–æ–≤—É—é —Å—Ö–µ–º—É
qc = QuantumCircuit(1)
qc.h(0)  # –ü—Ä–∏–º–µ–Ω—è–µ–º –≤–µ–Ω—Ç–∏–ª—å –ê–¥–∞–º–∞—Ä–∞
simulator = Aer.get_backend('statevector_simulator')
result = execute(qc, simulator).result()
statevector = result.get_statevector()
print("–°–æ—Å—Ç–æ—è–Ω–∏–µ –∫—É–±–∏—Ç–∞:", statevector)`;
      
      document.getElementById('colabCode').textContent = code;
      document.getElementById('colabCode').style.display = 'block';
      logEvent("–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω –∫–æ–¥ –¥–ª—è Colab");
    }

    // 6. –≠–∫—Å–ø–æ—Ä—Ç
    function exportToCSV() {
      const data = charts.signalChart.data.datasets[0].data.map((y, x) => ({ x, y }));
      const csv = Papa.unparse(data);
      downloadFile('quantum_signal.csv', csv);
      logEvent("–î–∞–Ω–Ω—ã–µ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã –≤ CSV");
    }

    function exportLogs() {
      const logs = document.getElementById('systemLogs').textContent;
      downloadFile('quantum_logs.txt', logs);
    }

    function downloadFile(filename, content) {
      const blob = new Blob([content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
    }

    // 7. –°–∏—Å—Ç–µ–º–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
    function clearLogs() {
      document.getElementById('systemLogs').textContent = "[–õ–æ–≥–∏ –æ—á–∏—â–µ–Ω—ã]\n";
    }

    function logEvent(message, isError = false) {
      const logs = document.getElementById('systemLogs');
      const timestamp = new Date().toLocaleTimeString();
      logs.innerHTML += `\n[${timestamp}] ${message}`;
      logs.scrollTop = logs.scrollHeight;
    }

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≥—Ä–∞—Ñ–∏–∫–æ–≤
    function initCharts() {
      charts.signalChart = new Chart(
        document.getElementById('signalChart').getContext('2d'),
        { type: 'line', options: { responsive: true, maintainAspectRatio: false } }
      );
      charts.digitalChart = new Chart(
        document.getElementById('digitalChart').getContext('2d'),
        { type: 'bar', options: { responsive: true, maintainAspectRatio: false } }
      );
    }

    function updateChart(id, data, label, color) {
      const chart = charts[id];
      chart.data = {
        labels: data.map((_, i) => i),
        datasets: [{
          label: label,
          data: data,
          borderColor: color,
          backgroundColor: id === 'digitalChart' ? color : undefined,
          borderWidth: 2
        }]
      };
      chart.update();
    }
  </script>
</body>
</html>